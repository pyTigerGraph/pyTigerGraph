{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pyTigerGraph pyTigerGraph is a Python package for connecting to TigerGraph databases. Getting Started To download pyTigerGraph, simply run: pip3 install pyTigerGraph Once the package installs, you can import it and instantiate a connection to your database: import pyTigerGraph as tg conn = tg.TigerGraphConnection(host=\"<hostname>\", graphname=\"<graph_name>\", username=\"<username>\", password=\"<password>\", apiToken=\"<api_token>\") If your database is not using the standard ports (or they are mapped), you can use the following arguments to specify those: * restppPort (default 9000): REST++ API port * gsPort (default: 14240): GraphStudio port For example, in case of using a local virtual machine with the ports mapped: conn = tg.TigerGraphConnection(host=\"localhost\", restppPort=25900, gsPort=25240, graphname=\"MyGraph\", username=\"tigergraph\", password=\"tigergraph\", apiToken=\"2aa016d747ede9gg6da3drslm98srfoj\") Example Projects GSQL101 on a notebook Connecting to TigerGraph Database with pyTigerGraph Predicting IPOs using Graph Convolutional Neural Networks Using pyTigergraph With Plotly TigerGraph to Tensorflow Movie Prediction with Graph Convolutional Neural Networks Credits pyTigerGraph was originally created by Parker Erickson, a Computer Science student at the University of Minnesota. Special thanks to contributors Jon Herke and Szilard Barany of TigerGraph. Read this to learn more about how you can contribute.","title":"Home"},{"location":"#pytigergraph","text":"pyTigerGraph is a Python package for connecting to TigerGraph databases.","title":"pyTigerGraph"},{"location":"#getting-started","text":"To download pyTigerGraph, simply run: pip3 install pyTigerGraph Once the package installs, you can import it and instantiate a connection to your database: import pyTigerGraph as tg conn = tg.TigerGraphConnection(host=\"<hostname>\", graphname=\"<graph_name>\", username=\"<username>\", password=\"<password>\", apiToken=\"<api_token>\") If your database is not using the standard ports (or they are mapped), you can use the following arguments to specify those: * restppPort (default 9000): REST++ API port * gsPort (default: 14240): GraphStudio port For example, in case of using a local virtual machine with the ports mapped: conn = tg.TigerGraphConnection(host=\"localhost\", restppPort=25900, gsPort=25240, graphname=\"MyGraph\", username=\"tigergraph\", password=\"tigergraph\", apiToken=\"2aa016d747ede9gg6da3drslm98srfoj\")","title":"Getting Started"},{"location":"#example-projects","text":"GSQL101 on a notebook Connecting to TigerGraph Database with pyTigerGraph Predicting IPOs using Graph Convolutional Neural Networks Using pyTigergraph With Plotly TigerGraph to Tensorflow Movie Prediction with Graph Convolutional Neural Networks","title":"Example Projects"},{"location":"#credits","text":"pyTigerGraph was originally created by Parker Erickson, a Computer Science student at the University of Minnesota. Special thanks to contributors Jon Herke and Szilard Barany of TigerGraph. Read this to learn more about how you can contribute.","title":"Credits"},{"location":"Auth/","text":"If user authentication is enabled in the TigerGraph database, then username and password need to be specified when the connection is established. If you already have an API authorization token, specify that one as well. Alternatively, if you know a secret (created previously in the database), you can request a token via the getToken function and use it during the session. If user authentication is not enabled, then username, password and authorization token are not used (i.e. the database is insecure). This is only acceptable in case of development or study environments. The username and password default to the TigerGraph default username and password, which are tigergraph . If user authentication is enabled, the tigergraph user's password can't be tigergraph, so a different one must be selected. Furthermore, it is recommended not to use the tigergraph user for anything other than system administration. Instead, create additional users and grant them the appropriate privileges through roles , then use those users to access the database. It is recommended to not push any form of authentication information to version control software. Because of this, we recommend to create a cfg.py file that looks like this: secret = \"YOUR_SECRET_HERE\" token = \"\" password = \"YOUR_PASSWORD_HERE\" You can then import this config file into your Python applications, and add cfg.py to your .gitignore . To create a connection to your database, simply: import pyTigerGraph as tg import cfg cfg.token = tg.TigerGraphConnection(host=\"<hostname>\", graphname=\"<graph_name>\").getToken(cfg.secret, \"<token_lifetime>\")[0] conn = tg.TigerGraphConnection(host=\"<hostname>\", graphname=\"<graph_name>\", password=cfg.password, apiToken=cfg.token) Substitute the hostname and graph name with the correct credentials, as well as the desired lifetime of the API token fetched.","title":"Authentication"},{"location":"CONTRIBUTING/","text":"Contribute to pyTigerGraph It is easy! Just follow the steps below: Fork the Original Repo Clone your forked Version Make additions, modifications Run git fetch upstream <branch> to make sure both repos are in sync Push to your forked Repo Issue Pull Request to the original repository","title":"Contribute"},{"location":"CONTRIBUTING/#contribute-to-pytigergraph","text":"It is easy! Just follow the steps below: Fork the Original Repo Clone your forked Version Make additions, modifications Run git fetch upstream <branch> to make sure both repos are in sync Push to your forked Repo Issue Pull Request to the original repository","title":"Contribute to pyTigerGraph"},{"location":"DataFrame/","text":"Graph To DataFrame The graphToDataFrame sub-module provides results from various built-in endpoints in a Pandas DataFrame. For this module to work, you will have to install the Pandas module, by running pip install pandas . Take a look here for some demos displaying some of the functionality. Getting Started First, you will need to create a TigerGraphConnection: import pyTigerGraph as tg conn = tg.TigerGraphConnection(host=\"https://20bd42e3162a40db9ca0a2f0a4352948.i.tgcloud.io\", graphname=\"CrunchBasePre_2013\", apiToken=token) getVertexDataframe getVertexDataframe(vertexType, select=\"\", where=\"\", limit=\"\", sort=\"\", timeout=0) Returns the verticies of a given vertex type that conform to the various arguments. Arguments: vertexType : Type of vertex desired select : Comma separated list of vertex attributes to be retrieved or omitted. See https://docs.tigergraph.com/dev/restpp-api/built-in-endpoints#select where : Comma separated list of conditions that are all applied on each vertex' attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). See https://docs.tigergraph.com/dev/restpp-api/built-in-endpoints#filter limit : Maximum number of vertex instances to be returned (after sorting). See https://docs.tigergraph.com/dev/restpp-api/built-in-endpoints#limit sort Comma separated list of attributes the results should be sorted by. See https://docs.tigergraph.com/dev/restpp-api/built-in-endpoints#sort Example: df = conn.getVertexDataframe(\"company\", limit=100) getVertexDataframeByID getVertexDataframeByID(vertexType, vertexIds) Retrieves vertices of the given vertex type, identified by their ID. Arguments: vertexType : Type of vertex desired vertexIds : A list of vertex IDs. Example: df = conn.getVertexDataframeByID(\"company\", [\"c:1\", \"c:2\"]) upsertVertexDataframe upsertVertexDataframe(df, vertexType, v_id=None, attributes=None) Upserts vertices from a Pandas data frame. Arguments: - df : The data frame to upsert. vertexType : The type of vertex to upsert data to. v_id : The field name where the vertex primary id is given. If omitted the dataframe index will be used instead. attributes : A dictionary in the form of {target: source} where source is the column name in the dataframe and target is the attribute name in the graph vertex. When omitted all columns would be upserted with their current names. In this case column names must match the vertex's attribute names. conn.upsertVertexDataframe(df=person, vertexType='person', v_id='name') getEdgesDataframe getEdgesDataframe(sourceVertexType, sourceVerticies, edgeType=None, targetVertexType=None, targetVertexId=None, select=\"\", where=\"\", limit=\"\", sort=\"\", timeout=0) Retrieves edges of the given edge type originating from the list of source verticies. Only sourceVertexType and sourceVerticies are required. If targetVertexId is specified, then targetVertexType must also be specified. If targetVertexType is specified, then edgeType must also be specified. Arguments: select : Comma separated list of edge attributes to be retrieved or omitted. See https://docs.tigergraph.com/dev/restpp-api/built-in-endpoints#select where : Comma separated list of conditions that are all applied on each edge's attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). See https://docs.tigergraph.com/dev/restpp-api/built-in-endpoints#filter limit : Maximum number of edge instances to be returned (after sorting). See https://docs.tigergraph.com/dev/restpp-api/built-in-endpoints#limit sort Comma separated list of attributes the results should be sorted by. See https://docs.tigergraph.com/dev/restpp-api/built-in-endpoints#sort Example: edgeDf = conn.getEdgesDataframe(\"company\", [\"c:1\", \"c:2\"]) upsertEdgesDataframe upsertEdgesDataframe(df, sourceVertexType, edgeType, targetVertexType, from_id=None, to_id=None, attributes=None) Upserts edges from a Pandas dataframe. Arguments: df : The dataframe to upsert. sourceVertexType : The type of source vertex for the edge. edgeType : The type of edge to upsert data to. targetVertexType : The type of target vertex for the edge. from_id : The field name where the source vertex primary id is given. If omitted the dataframe index would be used instead. to_id : The field name where the target vertex primary id is given. If omitted the dataframe index would be used instead. attributes : A dictionary in the form of {target: source} where source is the column name in the dataframe and target is the attribute name in the graph vertex. When omitted all columns would be upserted with their current names. In this case column names must match the vertex's attribute names. getInstalledQueriesDataframe getInstalledQueriesDataframe() Returns dataframe of all installed queries, does not take any arguments. Example: queries = conn.getInstalledQueriesDataframe()","title":"DataFrame Functions"},{"location":"DataFrame/#graph-to-dataframe","text":"The graphToDataFrame sub-module provides results from various built-in endpoints in a Pandas DataFrame. For this module to work, you will have to install the Pandas module, by running pip install pandas . Take a look here for some demos displaying some of the functionality.","title":"Graph To DataFrame"},{"location":"DataFrame/#getting-started","text":"First, you will need to create a TigerGraphConnection: import pyTigerGraph as tg conn = tg.TigerGraphConnection(host=\"https://20bd42e3162a40db9ca0a2f0a4352948.i.tgcloud.io\", graphname=\"CrunchBasePre_2013\", apiToken=token)","title":"Getting Started"},{"location":"DataFrame/#getvertexdataframe","text":"getVertexDataframe(vertexType, select=\"\", where=\"\", limit=\"\", sort=\"\", timeout=0) Returns the verticies of a given vertex type that conform to the various arguments. Arguments: vertexType : Type of vertex desired select : Comma separated list of vertex attributes to be retrieved or omitted. See https://docs.tigergraph.com/dev/restpp-api/built-in-endpoints#select where : Comma separated list of conditions that are all applied on each vertex' attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). See https://docs.tigergraph.com/dev/restpp-api/built-in-endpoints#filter limit : Maximum number of vertex instances to be returned (after sorting). See https://docs.tigergraph.com/dev/restpp-api/built-in-endpoints#limit sort Comma separated list of attributes the results should be sorted by. See https://docs.tigergraph.com/dev/restpp-api/built-in-endpoints#sort Example: df = conn.getVertexDataframe(\"company\", limit=100)","title":"getVertexDataframe"},{"location":"DataFrame/#getvertexdataframebyid","text":"getVertexDataframeByID(vertexType, vertexIds) Retrieves vertices of the given vertex type, identified by their ID. Arguments: vertexType : Type of vertex desired vertexIds : A list of vertex IDs. Example: df = conn.getVertexDataframeByID(\"company\", [\"c:1\", \"c:2\"])","title":"getVertexDataframeByID"},{"location":"DataFrame/#upsertvertexdataframe","text":"upsertVertexDataframe(df, vertexType, v_id=None, attributes=None) Upserts vertices from a Pandas data frame. Arguments: - df : The data frame to upsert. vertexType : The type of vertex to upsert data to. v_id : The field name where the vertex primary id is given. If omitted the dataframe index will be used instead. attributes : A dictionary in the form of {target: source} where source is the column name in the dataframe and target is the attribute name in the graph vertex. When omitted all columns would be upserted with their current names. In this case column names must match the vertex's attribute names. conn.upsertVertexDataframe(df=person, vertexType='person', v_id='name')","title":"upsertVertexDataframe"},{"location":"DataFrame/#getedgesdataframe","text":"getEdgesDataframe(sourceVertexType, sourceVerticies, edgeType=None, targetVertexType=None, targetVertexId=None, select=\"\", where=\"\", limit=\"\", sort=\"\", timeout=0) Retrieves edges of the given edge type originating from the list of source verticies. Only sourceVertexType and sourceVerticies are required. If targetVertexId is specified, then targetVertexType must also be specified. If targetVertexType is specified, then edgeType must also be specified. Arguments: select : Comma separated list of edge attributes to be retrieved or omitted. See https://docs.tigergraph.com/dev/restpp-api/built-in-endpoints#select where : Comma separated list of conditions that are all applied on each edge's attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). See https://docs.tigergraph.com/dev/restpp-api/built-in-endpoints#filter limit : Maximum number of edge instances to be returned (after sorting). See https://docs.tigergraph.com/dev/restpp-api/built-in-endpoints#limit sort Comma separated list of attributes the results should be sorted by. See https://docs.tigergraph.com/dev/restpp-api/built-in-endpoints#sort Example: edgeDf = conn.getEdgesDataframe(\"company\", [\"c:1\", \"c:2\"])","title":"getEdgesDataframe"},{"location":"DataFrame/#upsertedgesdataframe","text":"upsertEdgesDataframe(df, sourceVertexType, edgeType, targetVertexType, from_id=None, to_id=None, attributes=None) Upserts edges from a Pandas dataframe. Arguments: df : The dataframe to upsert. sourceVertexType : The type of source vertex for the edge. edgeType : The type of edge to upsert data to. targetVertexType : The type of target vertex for the edge. from_id : The field name where the source vertex primary id is given. If omitted the dataframe index would be used instead. to_id : The field name where the target vertex primary id is given. If omitted the dataframe index would be used instead. attributes : A dictionary in the form of {target: source} where source is the column name in the dataframe and target is the attribute name in the graph vertex. When omitted all columns would be upserted with their current names. In this case column names must match the vertex's attribute names.","title":"upsertEdgesDataframe"},{"location":"DataFrame/#getinstalledqueriesdataframe","text":"getInstalledQueriesDataframe() Returns dataframe of all installed queries, does not take any arguments. Example: queries = conn.getInstalledQueriesDataframe()","title":"getInstalledQueriesDataframe"},{"location":"EdgeFunctions/","text":"getEdgeTypes getEdgeTypes() Returns the list of edge type names of the graph. getEdgeType getEdgeType(typeName) Returns the details of vertex type. getEdgeCountFrom getEdgeCount(sourceVertexType=None, sourceVertexId=None, edgeType=None, targetVertexType=None, targetVertexId=None, where=\"\") Returns the number of edges. Arguments: - where : Comma separated list of conditions that are all applied on each edge's attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). Uses: - If edgeType = \"*\": edge count of all edge types (no other arguments can be specified in this case). - If edgeType is specified only: edge count of the given edge type. - If sourceVertexType , edgeType , targetVertexType are specified: edge count of the given edge type between source and target vertex types. - If sourceVertexType , sourceVertexId are specified: edge count of all edge types from the given vertex instance. - If sourceVertexType , sourceVertexId , edgeType are specified: edge count of all edge types from the given vertex instance. - If sourceVertexType , sourceVertexId , edgeType , where are specified: the edge count of the given edge type after filtered by where condition. If targetVertexId is specified, then targetVertexType must also be specified. If targetVertexType is specified, then edgeType must also be specified. Returns a dictionary of <edge_type>: <edge_count> pairs. Documentation: GET /graph/{graph_name}/edges and POST /builtins getEdgeCount getEdgeCount(self, edgeType=\"*\", sourceVertexType=None, targetVertexType=None) Returns the number of edges of an edge type. This is a simplified version of getEdgeCountFrom , to be used when the total number of edges of a given type is needed, regardless which vertex instance they are originated from. See documentation of getEdgeCountFrom above for more details. upsertEdge upsertEdge(sourceVertexType, sourceVertexId, edgeType, targetVertexType, targetVertexId, attributes={}) Upserts an edge. Data is upserted: - If edge is not yet present in graph, it will be created (see special case below). - If it's already in the graph, it is updated with the values specified in the request. An optional operator controls how the attributes are updated. The attributes argument is expected to be a dictionary in this format: {<attribute_name>, <attribute_value>|(<attribute_name>, <operator>), \u2026} Example: {\"visits\": (1482, \"+\"), \"max_duration\": (371, \"max\")} Returns a single number of accepted (successfully upserted) edges (0 or 1). Note: If operator is \"vertex_must_exist\" then edge will only be created if both vertex exists in graph. Otherwise missing vertices are created with the new edge. Documentation: POST /graph upsertEdges upsertEdges(sourceVertexType, edgeType, targetVertexType, edges) Upserts multiple edges (of the same type). See the description of upsertEdge for generic information. The edges argument is expected to be a list in of tuples in this format: [ (<source_vertex_id>, <target_vertex_id>, {<attribute_name>: <attribute_value>|(<attribute_name>, <operator>), \u2026}) \u22ee ] Example: [ (17, \"home_page\", {\"visits\": (35, \"+\"), \"max_duration\": (93, \"max\")}), (42, \"search\", {\"visits\": (17, \"+\"), \"max_duration\": (41, \"max\")}), ] Returns a single number of accepted (successfully upserted) edges (0 or positive integer). Documentation: POST /graph getEdges getEdges(sourceVertexType, sourceVertexId, edgeType=None, targetVertexType=None, targetVertexId=None, select=\"\", where=\"\", limit=\"\", sort=\"\", timeout=0) Retrieves edges of the given edge type. Only sourceVertexType and sourceVertexId are required. If targetVertexId is specified, then targetVertexType must also be specified. If targetVertexType is specified, then edgeType must also be specified. Arguments: - select : Comma separated list of edge attributes to be retrieved or omitted. - where : Comma separated list of conditions that are all applied on each edge's attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). - limit : Maximum number of edge instances to be returned (after sorting). - sort : Comma separated list of attributes the results should be sorted by. Documentation: GET /graph/{graph_name}/vertices getEdgeStats getEdgeStats(edgeTypes, skipNA=False) Returns edge attribute statistics. Arguments: - edgeTypes : A single edge type name or a list of edges types names or '*' for all edges types. - skipNA : Skip those n on- a pplicable edges that do not have attributes or none of their attributes have statistics gathered. Documentation: POST /builtins delEdges delEdges(sourceVertexType, sourceVertexId, edgeType=None, targetVertexType=None, targetVertexId=None, where=\"\", limit=\"\", sort=\"\", timeout=0) Deletes edges from the graph. Only sourceVertexType and sourceVertexId are required. If targetVertexId is specified, then targetVertexType must also be specified. If targetVertexType is specified, then edgeType must also be specified. Arguments: - where : Comma separated list of conditions that are all applied on each edge's attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). - limit : Maximum number of edge instances to be returned (after sorting). - sort : Comma separated list of attributes the results should be sorted by. - timeout : Time allowed for successful execution (0 = no limit, default). Returns a dictionary of <edge_type>: <deleted_edge_count> pairs. Documentation: DELETE /graph/{/graph_name}/edges","title":"Edge Functions"},{"location":"EdgeFunctions/#getedgetypes","text":"getEdgeTypes() Returns the list of edge type names of the graph.","title":"getEdgeTypes"},{"location":"EdgeFunctions/#getedgetype","text":"getEdgeType(typeName) Returns the details of vertex type.","title":"getEdgeType"},{"location":"EdgeFunctions/#getedgecountfrom","text":"getEdgeCount(sourceVertexType=None, sourceVertexId=None, edgeType=None, targetVertexType=None, targetVertexId=None, where=\"\") Returns the number of edges. Arguments: - where : Comma separated list of conditions that are all applied on each edge's attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). Uses: - If edgeType = \"*\": edge count of all edge types (no other arguments can be specified in this case). - If edgeType is specified only: edge count of the given edge type. - If sourceVertexType , edgeType , targetVertexType are specified: edge count of the given edge type between source and target vertex types. - If sourceVertexType , sourceVertexId are specified: edge count of all edge types from the given vertex instance. - If sourceVertexType , sourceVertexId , edgeType are specified: edge count of all edge types from the given vertex instance. - If sourceVertexType , sourceVertexId , edgeType , where are specified: the edge count of the given edge type after filtered by where condition. If targetVertexId is specified, then targetVertexType must also be specified. If targetVertexType is specified, then edgeType must also be specified. Returns a dictionary of <edge_type>: <edge_count> pairs. Documentation: GET /graph/{graph_name}/edges and POST /builtins","title":"getEdgeCountFrom"},{"location":"EdgeFunctions/#getedgecount","text":"getEdgeCount(self, edgeType=\"*\", sourceVertexType=None, targetVertexType=None) Returns the number of edges of an edge type. This is a simplified version of getEdgeCountFrom , to be used when the total number of edges of a given type is needed, regardless which vertex instance they are originated from. See documentation of getEdgeCountFrom above for more details.","title":"getEdgeCount"},{"location":"EdgeFunctions/#upsertedge","text":"upsertEdge(sourceVertexType, sourceVertexId, edgeType, targetVertexType, targetVertexId, attributes={}) Upserts an edge. Data is upserted: - If edge is not yet present in graph, it will be created (see special case below). - If it's already in the graph, it is updated with the values specified in the request. An optional operator controls how the attributes are updated. The attributes argument is expected to be a dictionary in this format: {<attribute_name>, <attribute_value>|(<attribute_name>, <operator>), \u2026} Example: {\"visits\": (1482, \"+\"), \"max_duration\": (371, \"max\")} Returns a single number of accepted (successfully upserted) edges (0 or 1). Note: If operator is \"vertex_must_exist\" then edge will only be created if both vertex exists in graph. Otherwise missing vertices are created with the new edge. Documentation: POST /graph","title":"upsertEdge"},{"location":"EdgeFunctions/#upsertedges","text":"upsertEdges(sourceVertexType, edgeType, targetVertexType, edges) Upserts multiple edges (of the same type). See the description of upsertEdge for generic information. The edges argument is expected to be a list in of tuples in this format: [ (<source_vertex_id>, <target_vertex_id>, {<attribute_name>: <attribute_value>|(<attribute_name>, <operator>), \u2026}) \u22ee ] Example: [ (17, \"home_page\", {\"visits\": (35, \"+\"), \"max_duration\": (93, \"max\")}), (42, \"search\", {\"visits\": (17, \"+\"), \"max_duration\": (41, \"max\")}), ] Returns a single number of accepted (successfully upserted) edges (0 or positive integer). Documentation: POST /graph","title":"upsertEdges"},{"location":"EdgeFunctions/#getedges","text":"getEdges(sourceVertexType, sourceVertexId, edgeType=None, targetVertexType=None, targetVertexId=None, select=\"\", where=\"\", limit=\"\", sort=\"\", timeout=0) Retrieves edges of the given edge type. Only sourceVertexType and sourceVertexId are required. If targetVertexId is specified, then targetVertexType must also be specified. If targetVertexType is specified, then edgeType must also be specified. Arguments: - select : Comma separated list of edge attributes to be retrieved or omitted. - where : Comma separated list of conditions that are all applied on each edge's attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). - limit : Maximum number of edge instances to be returned (after sorting). - sort : Comma separated list of attributes the results should be sorted by. Documentation: GET /graph/{graph_name}/vertices","title":"getEdges"},{"location":"EdgeFunctions/#getedgestats","text":"getEdgeStats(edgeTypes, skipNA=False) Returns edge attribute statistics. Arguments: - edgeTypes : A single edge type name or a list of edges types names or '*' for all edges types. - skipNA : Skip those n on- a pplicable edges that do not have attributes or none of their attributes have statistics gathered. Documentation: POST /builtins","title":"getEdgeStats"},{"location":"EdgeFunctions/#deledges","text":"delEdges(sourceVertexType, sourceVertexId, edgeType=None, targetVertexType=None, targetVertexId=None, where=\"\", limit=\"\", sort=\"\", timeout=0) Deletes edges from the graph. Only sourceVertexType and sourceVertexId are required. If targetVertexId is specified, then targetVertexType must also be specified. If targetVertexType is specified, then edgeType must also be specified. Arguments: - where : Comma separated list of conditions that are all applied on each edge's attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). - limit : Maximum number of edge instances to be returned (after sorting). - sort : Comma separated list of attributes the results should be sorted by. - timeout : Time allowed for successful execution (0 = no limit, default). Returns a dictionary of <edge_type>: <deleted_edge_count> pairs. Documentation: DELETE /graph/{/graph_name}/edges","title":"delEdges"},{"location":"Functions/","text":"The Functions Common arguments used in methods: - vertexType , sourceVertexType , targetVertexType : The name of a vertex type in the graph. Use getVertexTypes to fetch the list of vertex types currently in the graph. - vertexId , sourceVertexId , targetVertexId : The primary ID of a vertex instance (of the appropriate data type). - edgeType : The name of the edge type in the graph. Use getEdgeTypes to fetch the list of edge types currently in the graph. Schema related functions Query related functions Vertex related functions Edge related functions Token management Other functions getSchema runInstalledQuery getVertexTypes getEdgeTypes getToken echo getUDTs runInterpretedQuery getVertexType getEdgeType refreshToken getEndpoints getUDT getVertexCount getEdgeCount deleteToken getStatistics upsertData upsertVertex upsertEdge getVersion upsertVertices upsertEdges getVer getVertices getEdges getLicenseInfo getVerticesById getEdgeStats getVertexStats delEdges delVertices delVerticesById","title":"Overview"},{"location":"Functions/#the-functions","text":"Common arguments used in methods: - vertexType , sourceVertexType , targetVertexType : The name of a vertex type in the graph. Use getVertexTypes to fetch the list of vertex types currently in the graph. - vertexId , sourceVertexId , targetVertexId : The primary ID of a vertex instance (of the appropriate data type). - edgeType : The name of the edge type in the graph. Use getEdgeTypes to fetch the list of edge types currently in the graph. Schema related functions Query related functions Vertex related functions Edge related functions Token management Other functions getSchema runInstalledQuery getVertexTypes getEdgeTypes getToken echo getUDTs runInterpretedQuery getVertexType getEdgeType refreshToken getEndpoints getUDT getVertexCount getEdgeCount deleteToken getStatistics upsertData upsertVertex upsertEdge getVersion upsertVertices upsertEdges getVer getVertices getEdges getLicenseInfo getVerticesById getEdgeStats getVertexStats delEdges delVertices delVerticesById","title":"The Functions"},{"location":"GettingStarted/","text":"Getting Started To download pyTigerGraph, simply run: pip install pyTigerGraph Once the package installs, you can import it and instantiate a connection to your database: import pyTigerGraph as tg conn = tg.TigerGraphConnection(host=\"<hostname>\", graphname=\"<graph_name>\", username=\"<username>\", password=\"<password>\", apiToken=\"<api_token>\", version=\"<tg_version>\") If your database is not using the standard ports (or they are mapped), you can use the following arguments to specify those: - restppPort (default 9000): REST++ API port - gsPort (default: 14240): GraphStudio port For example, in case of using a local virtual machine with the ports mapped: conn = tg.TigerGraphConnection(host=\"localhost\", restppPort=25900, gsPort=25240, graphname=\"MyGraph\", username=\"tigergraph\", password=\"tigergraph\", apiToken=\"2aa016d747ede9gg6da3drslm98srfoj\") GSQL 101 With pyTigerGraph Checkout this example for completing the GSQL 101 course in a Jupyter Notebook environment. Through this, you will also learn of various pyTigerGraph methods that you can use. TigerGraphConnection pyTigerGraph.TigerGraphConnection( host=\"http://localhost\", graphname=\"MyGraph\", username=\"tigergraph\", password=\"tigergraph\", restppPort=\"9000\", gsPort=\"14240\", apiToken=\"\", useCert=True, clientVersion='3.0.0', secret=None) Initiate a connection object. Arguments - `host`: The ip address of the TigerGraph server. - `graphname`: The default graph for running queries. - `username`: The username on the TigerGraph server. - `password`: The password for that user. - `restppPort`: The post for REST++ queries. - `gsPort`: The port of all other queries. - `apiToken`: A token to use when making queries. - `useCert`: True if we need to use a certificate because the server is secure (such as on TigerGraph Cloud). This needs to be False when connecting to an unsecure server such as TigerGraph Developer. When True the certificate would be downloaded when it is first needed. on the first GSQL command. - `version`: Indicates which GSQL client version to download.","title":"Getting Started"},{"location":"GettingStarted/#getting-started","text":"To download pyTigerGraph, simply run: pip install pyTigerGraph Once the package installs, you can import it and instantiate a connection to your database: import pyTigerGraph as tg conn = tg.TigerGraphConnection(host=\"<hostname>\", graphname=\"<graph_name>\", username=\"<username>\", password=\"<password>\", apiToken=\"<api_token>\", version=\"<tg_version>\") If your database is not using the standard ports (or they are mapped), you can use the following arguments to specify those: - restppPort (default 9000): REST++ API port - gsPort (default: 14240): GraphStudio port For example, in case of using a local virtual machine with the ports mapped: conn = tg.TigerGraphConnection(host=\"localhost\", restppPort=25900, gsPort=25240, graphname=\"MyGraph\", username=\"tigergraph\", password=\"tigergraph\", apiToken=\"2aa016d747ede9gg6da3drslm98srfoj\")","title":"Getting Started"},{"location":"GettingStarted/#gsql-101-with-pytigergraph","text":"Checkout this example for completing the GSQL 101 course in a Jupyter Notebook environment. Through this, you will also learn of various pyTigerGraph methods that you can use.","title":"GSQL 101 With pyTigerGraph"},{"location":"GettingStarted/#tigergraphconnection","text":"pyTigerGraph.TigerGraphConnection( host=\"http://localhost\", graphname=\"MyGraph\", username=\"tigergraph\", password=\"tigergraph\", restppPort=\"9000\", gsPort=\"14240\", apiToken=\"\", useCert=True, clientVersion='3.0.0', secret=None) Initiate a connection object. Arguments - `host`: The ip address of the TigerGraph server. - `graphname`: The default graph for running queries. - `username`: The username on the TigerGraph server. - `password`: The password for that user. - `restppPort`: The post for REST++ queries. - `gsPort`: The port of all other queries. - `apiToken`: A token to use when making queries. - `useCert`: True if we need to use a certificate because the server is secure (such as on TigerGraph Cloud). This needs to be False when connecting to an unsecure server such as TigerGraph Developer. When True the certificate would be downloaded when it is first needed. on the first GSQL command. - `version`: Indicates which GSQL client version to download.","title":"TigerGraphConnection"},{"location":"Gsql/","text":"GSQL Submodule The GSQL submodule is integrated into TigerGraphConnection anf gets loaded the first time you execute one of its functions. It provides GSQL shell functionality, allowing you to create and execute queries, loading tasks, and authentication tasks. Java must be installed on the system. OpenSSL is also used, but you can provide your own certificate if OpenSSL is not installed on your system (see initGsql). Getting Started First, you will need to create a TigerGraphConnection: import pyTigerGraph as tg conn = tg.TigerGraphConnection( host=\"your.server.ip.address\", graphname=\"social\", password=\"yourpassword\", version=\"3.0.0\", #useCert=False ) When using a non-secure conncetion, for example to TigerGraph Developer, you must uncomment the useCert=False option. You can now initilize and test your connction by issuing any GSQL command like: print(conn.gsql('ls', options=[])) See the GSQL101 notebook for more examples. gsql conn.gsql(query, options=None) Runs a GSQL query and process the output. Arguments: - query : The text of the query to run as one string. - options : A list of strings that will be passed as options the the gsql_client. A None gets replaced with ['g', self.graphname] causeing the queries to run on the default graph. Use options=[] to overide the default graph and submit to the global enviroment instead. Once you have a TigerGraphConnection set up, you can use the gsql() method to send any GSQL query. By default, all commands are run using the graph that was passed in with the TigerGraphConnection. This is done using the gsql_client command line options. You can customize these command line options via the options argument, which takes in a list of strings. If you wish to run a query globaly simply pass options=[] . When the query resonse is a JSON formatted string the return value of gsql() would be a processed JSON object, otherwise the response text is returned as is. createSecret conn.createSecret(alias=\"\") Returns a secret key. Takes in a string as an argument if you want to use an alias while generating the key. initGsql ```conn.initGsql(jarLocation=\"~/.gsql\", certLocation=\"~/.gsql/my-cert.txt\") This commnad allows you to initiate the gsql submodule ahead of the first call to any other gsql submodule command. This allows you to customize the location at which the gsql_client.jar and the certificate will be stored. downloadJar and downloadCert Use conn.downloadJar=False and conn.downloadCert=Flase to prevent the downloads. This must be set before runing initGsql . Mostly this is useful when working with a user supplied gsql_client.jar file or certificate.","title":"GSQL Functions"},{"location":"Gsql/#gsql-submodule","text":"The GSQL submodule is integrated into TigerGraphConnection anf gets loaded the first time you execute one of its functions. It provides GSQL shell functionality, allowing you to create and execute queries, loading tasks, and authentication tasks. Java must be installed on the system. OpenSSL is also used, but you can provide your own certificate if OpenSSL is not installed on your system (see initGsql).","title":"GSQL Submodule"},{"location":"Gsql/#getting-started","text":"First, you will need to create a TigerGraphConnection: import pyTigerGraph as tg conn = tg.TigerGraphConnection( host=\"your.server.ip.address\", graphname=\"social\", password=\"yourpassword\", version=\"3.0.0\", #useCert=False ) When using a non-secure conncetion, for example to TigerGraph Developer, you must uncomment the useCert=False option. You can now initilize and test your connction by issuing any GSQL command like: print(conn.gsql('ls', options=[])) See the GSQL101 notebook for more examples.","title":"Getting Started"},{"location":"Gsql/#gsql","text":"conn.gsql(query, options=None) Runs a GSQL query and process the output. Arguments: - query : The text of the query to run as one string. - options : A list of strings that will be passed as options the the gsql_client. A None gets replaced with ['g', self.graphname] causeing the queries to run on the default graph. Use options=[] to overide the default graph and submit to the global enviroment instead. Once you have a TigerGraphConnection set up, you can use the gsql() method to send any GSQL query. By default, all commands are run using the graph that was passed in with the TigerGraphConnection. This is done using the gsql_client command line options. You can customize these command line options via the options argument, which takes in a list of strings. If you wish to run a query globaly simply pass options=[] . When the query resonse is a JSON formatted string the return value of gsql() would be a processed JSON object, otherwise the response text is returned as is.","title":"gsql"},{"location":"Gsql/#createsecret","text":"conn.createSecret(alias=\"\") Returns a secret key. Takes in a string as an argument if you want to use an alias while generating the key.","title":"createSecret"},{"location":"Gsql/#initgsql","text":"```conn.initGsql(jarLocation=\"~/.gsql\", certLocation=\"~/.gsql/my-cert.txt\") This commnad allows you to initiate the gsql submodule ahead of the first call to any other gsql submodule command. This allows you to customize the location at which the gsql_client.jar and the certificate will be stored.","title":"initGsql"},{"location":"Gsql/#downloadjar-and-downloadcert","text":"Use conn.downloadJar=False and conn.downloadCert=Flase to prevent the downloads. This must be set before runing initGsql . Mostly this is useful when working with a user supplied gsql_client.jar file or certificate.","title":"downloadJar and downloadCert"},{"location":"OtherFunctions/","text":"echo echo() Pings the database. Expected return value is \"Hello GSQL\" Documentation: GET /echo and POST /echo getEndpoints getEndpoints(builtin=False, dynamic=False, static=False) Lists the REST++ endpoints and their parameters. Arguments: - builtin : TigerGraph provided REST++ endpoints. - dymamic : Endpoints for user installed queries. - static : Static endpoints. If none of the above arguments are specified, all endpoints are listed. Documentation: GET /endpoints getStatistics getStatistics(seconds=10, segment=10) Arguments: - seconds : The duration of statistic collection period (the last n seconds before the function call). - segments : The number of segments of the latency distribution (shown in results as LatencyPercentile). By default, segments is 10, meaning the percentile range 0-100% will be divided into ten equal segments: 0%-10%, 11%-20%, etc. Segments must be [1, 100]. Retrieves real-time query performance statistics over the given time period. Documentation: GET /statistics getVersion getVersion() Retrieves the git versions of all components of the system. Documentation: GET /version getVer getVer(component=\"product\", full=False) Arguments: - component : One of TigerGraph's components (e.g. product, gpe, gse). Gets the version information of specific component. Get the full list of components using getVersion . getLicenseInfo getLicenseInfo() Returns the expiration date and remaining days of the license. In case of evaluation/trial deployment, an information message and -1 remaining days are returned.","title":"Other Functions"},{"location":"OtherFunctions/#echo","text":"echo() Pings the database. Expected return value is \"Hello GSQL\" Documentation: GET /echo and POST /echo","title":"echo"},{"location":"OtherFunctions/#getendpoints","text":"getEndpoints(builtin=False, dynamic=False, static=False) Lists the REST++ endpoints and their parameters. Arguments: - builtin : TigerGraph provided REST++ endpoints. - dymamic : Endpoints for user installed queries. - static : Static endpoints. If none of the above arguments are specified, all endpoints are listed. Documentation: GET /endpoints","title":"getEndpoints"},{"location":"OtherFunctions/#getstatistics","text":"getStatistics(seconds=10, segment=10) Arguments: - seconds : The duration of statistic collection period (the last n seconds before the function call). - segments : The number of segments of the latency distribution (shown in results as LatencyPercentile). By default, segments is 10, meaning the percentile range 0-100% will be divided into ten equal segments: 0%-10%, 11%-20%, etc. Segments must be [1, 100]. Retrieves real-time query performance statistics over the given time period. Documentation: GET /statistics","title":"getStatistics"},{"location":"OtherFunctions/#getversion","text":"getVersion() Retrieves the git versions of all components of the system. Documentation: GET /version","title":"getVersion"},{"location":"OtherFunctions/#getver","text":"getVer(component=\"product\", full=False) Arguments: - component : One of TigerGraph's components (e.g. product, gpe, gse). Gets the version information of specific component. Get the full list of components using getVersion .","title":"getVer"},{"location":"OtherFunctions/#getlicenseinfo","text":"getLicenseInfo() Returns the expiration date and remaining days of the license. In case of evaluation/trial deployment, an information message and -1 remaining days are returned.","title":"getLicenseInfo"},{"location":"QueryFunctions/","text":"runInstalledQuery runInstalledQuery(queryName, params=None, timeout=16000, sizeLimit=32000000) Sample example: conn.runInstalledQuery(\"getUserInfo\", {'userID': 'user121'}) Runs an installed query. The query must be already created and installed in the graph. Use getEndpoints(dynamic=True) or GraphStudio to find out the generated endpoint URL of the query, but only the query name needs to be specified here. Arguments: - params : A string of param1=value1&param2=value2 format or a dictionary. - timeout : Maximum duration for successful query execution. - sizeLimit : Maximum size of response (in bytes). Documentation: POST /query/{graph_name}/ runInterpretedQuery runInterpretedQuery(queryText, params=None) Runs an interpreted query. You must provide the query text in this format: INTERPRET QUERY (<params>) FOR GRAPH <graph_name> { <statements> }' Arguments: - params : A string of param1=value1&param2=value2 format or a dictionary. Documentation: POST /gsqlserver/interpreted_query","title":"Query Functions"},{"location":"QueryFunctions/#runinstalledquery","text":"runInstalledQuery(queryName, params=None, timeout=16000, sizeLimit=32000000) Sample example: conn.runInstalledQuery(\"getUserInfo\", {'userID': 'user121'}) Runs an installed query. The query must be already created and installed in the graph. Use getEndpoints(dynamic=True) or GraphStudio to find out the generated endpoint URL of the query, but only the query name needs to be specified here. Arguments: - params : A string of param1=value1&param2=value2 format or a dictionary. - timeout : Maximum duration for successful query execution. - sizeLimit : Maximum size of response (in bytes). Documentation: POST /query/{graph_name}/","title":"runInstalledQuery"},{"location":"QueryFunctions/#runinterpretedquery","text":"runInterpretedQuery(queryText, params=None) Runs an interpreted query. You must provide the query text in this format: INTERPRET QUERY (<params>) FOR GRAPH <graph_name> { <statements> }' Arguments: - params : A string of param1=value1&param2=value2 format or a dictionary. Documentation: POST /gsqlserver/interpreted_query","title":"runInterpretedQuery"},{"location":"SchemaFunctions/","text":"getSchema getSchema(udts=True) Retrieves the schema (all vertex and edge type and - if not disabled - the User Defined Type details) of the graph. TigerGraph Documentation: GET /gsqlserver/gsql/schema getUDTs getUDTs() Returns the list of User Defined Types (names only). getUDT getUDT(udtName) Returns the details of a specific User Defined Type. upsertData upsertData(data) Upserts data (vertices and edges) from a JSON document or equivalent object structure. TigerGraph Documentation: POST /graph","title":"Schema Functions"},{"location":"SchemaFunctions/#getschema","text":"getSchema(udts=True) Retrieves the schema (all vertex and edge type and - if not disabled - the User Defined Type details) of the graph. TigerGraph Documentation: GET /gsqlserver/gsql/schema","title":"getSchema"},{"location":"SchemaFunctions/#getudts","text":"getUDTs() Returns the list of User Defined Types (names only).","title":"getUDTs"},{"location":"SchemaFunctions/#getudt","text":"getUDT(udtName) Returns the details of a specific User Defined Type.","title":"getUDT"},{"location":"SchemaFunctions/#upsertdata","text":"upsertData(data) Upserts data (vertices and edges) from a JSON document or equivalent object structure. TigerGraph Documentation: POST /graph","title":"upsertData"},{"location":"TokenManagement/","text":"getToken getToken(secret, setToken=True, lifetime=None) Requests an authorisation token. This function returns a token only if REST++ authentication is enabled . If not, an exception will be raised. Arguments: - secret : The secret (string) generated in GSQL using CREATE SECRET . - setToken : Set the connection's API token to the new value (default: True ). - lifetime : Duration of token validity (in secs, default 30 days = 2,592,000 secs). Returns a tuple of (<new_token>, <exporation_timestamp_unixtime>, <expiration_timestamp_ISO8601>) . Return value can be ignored. Note: expiration timestamp's time zone might be different from your computer's local time zone. Documentation: GET /requesttoken refreshToken refreshToken(secret, token=None, lifetime=2592000) Extends a token's lifetime. This function works only if REST++ authentication is enabled . If not, an exception will be raised. Arguments: - secret : The secret (string) generated in GSQL using CREATE SECRET . - token : The token requested earlier. If not specified, refreshes current connection's token. - lifetime : Duration of token validity (in secs, default 30 days = 2,592,000 secs). Returns a tuple of (<token>, <exporation_timestamp_unixtime>, <expiration_timestamp_ISO8601>) . Return value can be ignored. Raises exception if specified token does not exists. Note: - New expiration timestamp will be now + lifetime seconds , not current expiration timestamp + lifetime seconds . - Expiration timestamp's time zone might be different from your computer's local time zone. Documentation: PUT /requesttoken deleteToken deleteToken(secret, token) Deletes a token. This function works only if REST++ authentication is enabled . If not, an exception will be raised. Arguments: - secret : The secret (string) generated in GSQL using CREATE SECRET . - token : The token requested earlier. If not specified, deletes current connection's token, so be careful. - skipNA : Don't raise exception if specified token does not exist. Returns True if deletion was successful or token did not exist but skipNA was True ; raises exception otherwise. Documentation: DELETE /requesttoken","title":"API Tokens"},{"location":"TokenManagement/#gettoken","text":"getToken(secret, setToken=True, lifetime=None) Requests an authorisation token. This function returns a token only if REST++ authentication is enabled . If not, an exception will be raised. Arguments: - secret : The secret (string) generated in GSQL using CREATE SECRET . - setToken : Set the connection's API token to the new value (default: True ). - lifetime : Duration of token validity (in secs, default 30 days = 2,592,000 secs). Returns a tuple of (<new_token>, <exporation_timestamp_unixtime>, <expiration_timestamp_ISO8601>) . Return value can be ignored. Note: expiration timestamp's time zone might be different from your computer's local time zone. Documentation: GET /requesttoken","title":"getToken"},{"location":"TokenManagement/#refreshtoken","text":"refreshToken(secret, token=None, lifetime=2592000) Extends a token's lifetime. This function works only if REST++ authentication is enabled . If not, an exception will be raised. Arguments: - secret : The secret (string) generated in GSQL using CREATE SECRET . - token : The token requested earlier. If not specified, refreshes current connection's token. - lifetime : Duration of token validity (in secs, default 30 days = 2,592,000 secs). Returns a tuple of (<token>, <exporation_timestamp_unixtime>, <expiration_timestamp_ISO8601>) . Return value can be ignored. Raises exception if specified token does not exists. Note: - New expiration timestamp will be now + lifetime seconds , not current expiration timestamp + lifetime seconds . - Expiration timestamp's time zone might be different from your computer's local time zone. Documentation: PUT /requesttoken","title":"refreshToken"},{"location":"TokenManagement/#deletetoken","text":"deleteToken(secret, token) Deletes a token. This function works only if REST++ authentication is enabled . If not, an exception will be raised. Arguments: - secret : The secret (string) generated in GSQL using CREATE SECRET . - token : The token requested earlier. If not specified, deletes current connection's token, so be careful. - skipNA : Don't raise exception if specified token does not exist. Returns True if deletion was successful or token did not exist but skipNA was True ; raises exception otherwise. Documentation: DELETE /requesttoken","title":"deleteToken"},{"location":"VertexFunctions/","text":"getVertexTypes getVertexTypes() Returns the list of vertex type names of the graph. getVertexType getVertexType(vertexType) Returns the details of the specified vertex type. getVertexCount getVertexCount(vertexType, where=\"\") Return the number of vertices. Arguments: - where : Comma separated list of conditions that are all applied on each vertex' attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). Uses: - If vertexType = \"*\": vertex count of all vertex types ( where cannot be specified in this case) - If vertexType is specified only: vertex count of the given type - If vertexType and where are specified: vertex count of the given type after filtered by where condition(s) See documentation for valid values of where condition. Returns a dictionary of <vertex_type>: <vertex_count> pairs. Documentation: GET /graph/{graph_name}/vertices and POST /builtins upsertVertex upsertVertex(vertexType, vertexId, attributes=None) Upserts a vertex. Data is upserted: - If vertex is not yet present in graph, it will be created. - If it's already in the graph, its attributes are updated with the values specified in the request. An optional operator controls how the attributes are updated. The attributes argument is expected to be a dictionary in this format: {<attribute_name>, <attribute_value>|(<attribute_name>, <operator>), \u2026} Example: {\"name\": \"Thorin\", \"points\": (10, \"+\"), \"bestScore\": (67, \"max\")} Returns a single number of accepted (successfully upserted) vertices (0 or 1). Documentation: POST /graph upsertVertices upsertVertices(vertexType, vertices) Upserts multiple vertices (of the same type). See the description of upsertVertex for generic information. The vertices argument is expected to be a list of tuples in this format: [ (<vertex_id>, {<attribute_name>, <attribute_value>|(<attribute_name>, <operator>), \u2026}), \u22ee ] Example: [ (2, {\"name\": \"Balin\", \"points\": (10, \"+\"), \"bestScore\": (67, \"max\")}), (3, {\"name\": \"Dwalin\", \"points\": (7, \"+\"), \"bestScore\": (35, \"max\")}), ] Returns a single number of accepted (successfully upserted) vertices (0 or positive integer). Documentation: POST /graph getVertices getVertices(vertexType, select=\"\", where=\"\", limit=\"\", sort=\"\", timeout=0) Retrieves vertices of the given vertex type. Arguments: - select : Comma separated list of vertex attributes to be retrieved or omitted. - where : Comma separated list of conditions that are all applied on each vertex' attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). - limit : Maximum number of vertex instances to be returned (after sorting). - sort : Comma separated list of attributes the results should be sorted by. NOTE: The primary ID of a vertex instance is NOT an attribute, thus cannot be used in above arguments. Use getVerticesById if you need to retrieve by vertex ID. Documentation: GET /graph/{graph_name}/vertices getVerticesById getVerticesById(vertexType, vertexIds) Retrieves vertices of the given vertex type, identified by their ID. Arguments - vertexIds : A single vertex ID or a list of vertex IDs. Documentation: GET /graph/{graph_name}/vertices getVertexStats getVertexStats(vertexTypes, skipNA=False) Returns vertex attribute statistics. Arguments: - vertexTypes : A single vertex type name or a list of vertex types names or '*' for all vertex types. - skipNA : Skip those n on- a pplicable vertices that do not have attributes or none of their attributes have statistics gathered. Documentation: POST /builtins delVertices delVertices(vertexType, where=\"\", limit=\"\", sort=\"\", permanent=False, timeout=0) Deletes vertices from graph. Arguments: - where : Comma separated list of conditions that are all applied on each vertex' attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). - limit : Maximum number of vertex instances to be returned (after sorting). Must be used with sort . - sort : Comma separated list of attributes the results should be sorted by. Must be user with limit . - permanent : If true, the deleted vertex IDs can never be inserted back, unless the graph is dropped or the graph store is cleared. - timeout : Time allowed for successful execution (0 = no limit, default). NOTE: The primary ID of a vertex instance is NOT an attribute, thus cannot be used in above arguments. Use delVerticesById if you need to delete by vertex ID. Returns a single number of vertices deleted. Documentation: DELETE /graph/{graph_name}/vertices delVerticesById delVerticesById(vertexType, vertexIds, permanent=False, timeout=0) Deletes vertices from graph identified by their ID. Arguments: - vertexIds : A single vertex ID or a list of vertex IDs. - permanent : If true, the deleted vertex IDs can never be inserted back, unless the graph is dropped or the graph store is cleared. - timeout : Time allowed for successful execution (0 = no limit, default). Returns a single number of vertices deleted. Documentation: DELETE /graph/{graph_name}/vertices","title":"Vertex Functions"},{"location":"VertexFunctions/#getvertextypes","text":"getVertexTypes() Returns the list of vertex type names of the graph.","title":"getVertexTypes"},{"location":"VertexFunctions/#getvertextype","text":"getVertexType(vertexType) Returns the details of the specified vertex type.","title":"getVertexType"},{"location":"VertexFunctions/#getvertexcount","text":"getVertexCount(vertexType, where=\"\") Return the number of vertices. Arguments: - where : Comma separated list of conditions that are all applied on each vertex' attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). Uses: - If vertexType = \"*\": vertex count of all vertex types ( where cannot be specified in this case) - If vertexType is specified only: vertex count of the given type - If vertexType and where are specified: vertex count of the given type after filtered by where condition(s) See documentation for valid values of where condition. Returns a dictionary of <vertex_type>: <vertex_count> pairs. Documentation: GET /graph/{graph_name}/vertices and POST /builtins","title":"getVertexCount"},{"location":"VertexFunctions/#upsertvertex","text":"upsertVertex(vertexType, vertexId, attributes=None) Upserts a vertex. Data is upserted: - If vertex is not yet present in graph, it will be created. - If it's already in the graph, its attributes are updated with the values specified in the request. An optional operator controls how the attributes are updated. The attributes argument is expected to be a dictionary in this format: {<attribute_name>, <attribute_value>|(<attribute_name>, <operator>), \u2026} Example: {\"name\": \"Thorin\", \"points\": (10, \"+\"), \"bestScore\": (67, \"max\")} Returns a single number of accepted (successfully upserted) vertices (0 or 1). Documentation: POST /graph","title":"upsertVertex"},{"location":"VertexFunctions/#upsertvertices","text":"upsertVertices(vertexType, vertices) Upserts multiple vertices (of the same type). See the description of upsertVertex for generic information. The vertices argument is expected to be a list of tuples in this format: [ (<vertex_id>, {<attribute_name>, <attribute_value>|(<attribute_name>, <operator>), \u2026}), \u22ee ] Example: [ (2, {\"name\": \"Balin\", \"points\": (10, \"+\"), \"bestScore\": (67, \"max\")}), (3, {\"name\": \"Dwalin\", \"points\": (7, \"+\"), \"bestScore\": (35, \"max\")}), ] Returns a single number of accepted (successfully upserted) vertices (0 or positive integer). Documentation: POST /graph","title":"upsertVertices"},{"location":"VertexFunctions/#getvertices","text":"getVertices(vertexType, select=\"\", where=\"\", limit=\"\", sort=\"\", timeout=0) Retrieves vertices of the given vertex type. Arguments: - select : Comma separated list of vertex attributes to be retrieved or omitted. - where : Comma separated list of conditions that are all applied on each vertex' attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). - limit : Maximum number of vertex instances to be returned (after sorting). - sort : Comma separated list of attributes the results should be sorted by. NOTE: The primary ID of a vertex instance is NOT an attribute, thus cannot be used in above arguments. Use getVerticesById if you need to retrieve by vertex ID. Documentation: GET /graph/{graph_name}/vertices","title":"getVertices"},{"location":"VertexFunctions/#getverticesbyid","text":"getVerticesById(vertexType, vertexIds) Retrieves vertices of the given vertex type, identified by their ID. Arguments - vertexIds : A single vertex ID or a list of vertex IDs. Documentation: GET /graph/{graph_name}/vertices","title":"getVerticesById"},{"location":"VertexFunctions/#getvertexstats","text":"getVertexStats(vertexTypes, skipNA=False) Returns vertex attribute statistics. Arguments: - vertexTypes : A single vertex type name or a list of vertex types names or '*' for all vertex types. - skipNA : Skip those n on- a pplicable vertices that do not have attributes or none of their attributes have statistics gathered. Documentation: POST /builtins","title":"getVertexStats"},{"location":"VertexFunctions/#delvertices","text":"delVertices(vertexType, where=\"\", limit=\"\", sort=\"\", permanent=False, timeout=0) Deletes vertices from graph. Arguments: - where : Comma separated list of conditions that are all applied on each vertex' attributes. The conditions are in logical conjunction (i.e. they are \"AND'ed\" together). - limit : Maximum number of vertex instances to be returned (after sorting). Must be used with sort . - sort : Comma separated list of attributes the results should be sorted by. Must be user with limit . - permanent : If true, the deleted vertex IDs can never be inserted back, unless the graph is dropped or the graph store is cleared. - timeout : Time allowed for successful execution (0 = no limit, default). NOTE: The primary ID of a vertex instance is NOT an attribute, thus cannot be used in above arguments. Use delVerticesById if you need to delete by vertex ID. Returns a single number of vertices deleted. Documentation: DELETE /graph/{graph_name}/vertices","title":"delVertices"},{"location":"VertexFunctions/#delverticesbyid","text":"delVerticesById(vertexType, vertexIds, permanent=False, timeout=0) Deletes vertices from graph identified by their ID. Arguments: - vertexIds : A single vertex ID or a list of vertex IDs. - permanent : If true, the deleted vertex IDs can never be inserted back, unless the graph is dropped or the graph store is cleared. - timeout : Time allowed for successful execution (0 = no limit, default). Returns a single number of vertices deleted. Documentation: DELETE /graph/{graph_name}/vertices","title":"delVerticesById"},{"location":"license/","text":"MIT License Copyright (c) 2020 Parker Erickson Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"}]}